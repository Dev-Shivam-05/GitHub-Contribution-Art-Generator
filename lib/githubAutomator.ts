import { Octokit } from "octokit";

// Helper: Pause execution
const wait = (ms: number) => new Promise(resolve => setTimeout(resolve, ms));

interface HttpErrorLike {
    status?: number;
    response?: { status?: number };
    message?: string;
    code?: string;
    name?: string;
}

const getStatus = (error: unknown): number | undefined => {
    const e = error as HttpErrorLike | undefined;
    return e?.status ?? e?.response?.status;
};

const getMessage = (error: unknown): string => {
    const e = error as HttpErrorLike | undefined;
    return e?.message ?? 'Unknown Error';
};

// Helper: Retry logic
export async function withRetry<T>(
    operation: () => Promise<T>, 
    actionName: string, 
    maxRetries: number = 5, 
    baseDelay: number = 1000
): Promise<T> {
    let lastError: unknown;
    for (let attempt = 1; attempt <= maxRetries; attempt++) {
        try {
            return await operation();
        } catch (error: unknown) {
            lastError = error;
            const status = getStatus(error);
            const isRetryable = !status || (status >= 500 && status < 600) || status === 403 || status === 429;
            
            if (!isRetryable) {
                console.error(`Non-retryable error during ${actionName}: ${getMessage(error)}`);
                throw error as Error;
            }
            if (attempt === maxRetries) break;

            const delay = baseDelay * Math.pow(2, attempt - 1);
            console.warn(`Attempt ${attempt} failed for ${actionName}. Retrying in ${delay}ms...`);
            await wait(delay);
        }
    }
    throw lastError;
}

// MAIN FUNCTION
export async function automateGitHubProcess(
    userToken: string, 
    patternSchedule: Array<{ date: string; message: string }>, 
    repoName: string, 
    username: string,
    userEmail: string
) {
    const octokit = new Octokit({ 
        auth: userToken,
        request: { timeout: 30000 } 
    });

    try {
        console.log(`--- STARTING PROCESS FOR: ${username} ---`);

        // 1. Check User & Repo
        const [authUser, existingRepoResult] = await Promise.all([
            withRetry(() => octokit.rest.users.getAuthenticated(), "Get Authenticated User"),
            (async () => {
                try {
                    return await octokit.rest.repos.get({ owner: username, repo: repoName });
                } catch (e: unknown) {
                    if (getStatus(e) === 404) return null;
                    throw e;
                }
            })()
        ]);
        
        const committerEmail = userEmail || authUser.data.email || `${authUser.data.id}+${authUser.data.login}@users.noreply.github.com`;
        const committerName = authUser.data.name || authUser.data.login;

        // 2. Create Repo if needed
        const finalRepoName = repoName || (existingRepoResult ? existingRepoResult.data.name : `github-art-${Date.now()}`);
        let repo: unknown = existingRepoResult;
        
        if (!repo) {
             console.log(`Creating repository: ${finalRepoName}`);
             
            repo = await withRetry(
                () => octokit.rest.repos.createForAuthenticatedUser({
                    name: finalRepoName,
                    private: false, // <--- FIX 1: PUBLIC REPO (Ensures graph visibility)
                    auto_init: true, 
                    license_template: 'mit',
                    description: 'Generated by Contribution Art',
                }),
                "Create Repository"
            );
            
            console.log("Repo created. Waiting 5 seconds for propagation...");
            await wait(5000); 

            // Enable Actions (Just in case)
            try {
                await octokit.rest.actions.setGithubActionsPermissionsRepository({
                    owner: username,
                    repo: finalRepoName,
                    enabled: true,
                    allowed_actions: 'all'
                });
            } catch { /* Ignore if org restricted */ }
        }

        // 3. Generate Workflow YAML
        const scheduleJson = JSON.stringify(patternSchedule);
        const base64Schedule = Buffer.from(scheduleJson).toString('base64');
        
        const workflowContent = `name: Generate Contribution Art
on:
  workflow_dispatch: {} 

permissions:
  contents: write

jobs:
  paint-art:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Configure Git
        run: |
          git config user.name "${committerName}"
          git config user.email "${committerEmail}"

      - name: Process Art Schedule
        run: |
          echo "${base64Schedule}" | base64 -d > schedule.json
          jq -c '.[]' schedule.json | while read commit; do
            DATE=$(echo "$commit" | jq -r '.date')
            MSG=$(echo "$commit" | jq -r '.message')
            GIT_AUTHOR_DATE="$DATE 12:00:00" GIT_COMMITTER_DATE="$DATE 12:00:00" \\
            git commit --allow-empty -m "$MSG"
          done

      - name: Push Commits
        run: git push origin main
`;

        // 4. Upload the Workflow File
        console.log(`Uploading workflow to ${finalRepoName}...`);
        
        await withRetry(
            async () => {
                let sha;
                try {
                    const file = await octokit.rest.repos.getContent({
                        owner: username, 
                        repo: finalRepoName, 
                        path: '.github/workflows/generate_art.yml'
                    });
                    // @ts-expect-error: file.data type is not fully inferred by Octokit here
                    sha = file.data.sha;
                } catch {}

                await octokit.rest.repos.createOrUpdateFileContents({
                    owner: username,
                    repo: finalRepoName,
                    path: '.github/workflows/generate_art.yml',
                    message: 'Update Art Workflow',
                    content: Buffer.from(workflowContent).toString('base64'),
                    sha,
                    committer: { name: committerName, email: committerEmail },
                    author: { name: committerName, email: committerEmail }
                });
            },
            "Upload Workflow File"
        );
        
        console.log("File uploaded. Waiting 5 seconds for Actions to index...");
        await wait(5000); // Wait for GitHub to 'see' the workflow

        // 5. FIX 2: EXPLICITLY TRIGGER THE WORKFLOW
        console.log("Triggering Workflow automatically...");
        
        await withRetry(
            async () => {
                await octokit.rest.actions.createWorkflowDispatch({
                    owner: username,
                    repo: finalRepoName,
                    workflow_id: 'generate_art.yml',
                    ref: 'main', 
                });
            },
            "Trigger Workflow"
        );

        console.log('Workflow triggered successfully.');
        return `https://github.com/${username}/${finalRepoName}/actions`;

    } catch (error: unknown) {
        console.error(`Process Failed: ${getMessage(error)}`);
        throw error as Error;
    }
}
