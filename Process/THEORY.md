# Theory of Operation: Project Blacksmith

## 1. Temporal Mapping Algebra

At the core of Blacksmith lies the **Temporal Mapping Algebra**, a formal system for translating abstract pattern strings into discrete temporal events.

Let $P$ be a pattern string of length $L$.
Let $S$ be the start date (Epoch).
Let $D_i$ be the $i$-th day offset from $S$.
Let $C(D_i)$ be the commit count for day $D_i$.

We define the mapping function $f: \mathbb{Z}^+ \to \mathbb{Z}^+$ such that:

$$ C(D_i) = \text{Map}(P[i \pmod L]) $$

Where $\text{Map}$ is a function determined by the Pattern Grammar:

*   **Binary Group:** $\text{Map}(x) = 1$ if $x='1'$, else $0$.
*   **Weekday Group (Cyclic):** $\text{Map}(x) = I$ (intensity) if $x$ corresponds to the current weekday of $D_i$, else $0$.
*   **Fractal Group:** Defined recursively where $C(D_i)$ is determined by the inclusion of $i$ in the set generated by the fractal iteration function (e.g., Sierpinski).

This algebraic approach ensures that patterns are deterministic, cyclic, and mathematically verifiable across any time span.

## 2. Git Forensic Analysis

Standard Git commits are snapshots of a filesystem tree. However, the commit object itself is distinct from the tree it points to.

### The "Empty" Commit
A commit in Git is defined by:
1.  **Tree Hash:** Pointer to the directory structure.
2.  **Parent Hash(es):** Predecessor commit(s).
3.  **Author/Committer Info:** Name, Email, **Timestamp**.
4.  **Message.**

An "empty commit" (`git commit --allow-empty`) creates a new commit object that points to the **exact same tree hash** as its parent.
*   **Forensic Footprint:** `git log` shows the commit. `git diff HEAD^` returns nothing.
*   **GitHub Interpretation:** GitHub's contribution graph parses the **Author Date** from the commit object header, ignoring the file contents.

### Timestamp Manipulation
Git stores two dates:
1.  `GIT_AUTHOR_DATE`: When the code was written.
2.  `GIT_COMMITTER_DATE`: When the commit was applied.

Blacksmith manipulates **both** to ensure historical consistency. By setting these environment variables during the `git commit` invocation, we can place a commit at any point in the spacetime continuum, provided it is topologically valid (i.e., we respect parent-child relationships, though Git allows out-of-order dates, they may look suspicious).

## 3. Topology of Failure

Blacksmith assumes a hostile environment. We define the **Failure Topology** as the set of all possible error states $E$.

### Failure Domains
1.  **Network/API Layer ($E_{net}$):** Connection timeouts, DNS failures, GitHub 5xx errors.
    *   *Mitigation:* Exponential backoff, Circuit Breaker pattern.
2.  **Authentication Layer ($E_{auth}$):** SSH key rejection, PAT expiration.
    *   *Mitigation:* Pre-flight authentication checks (`ssh -T git@github.com`).
3.  **Local Git State ($E_{git}$):** Locked index file, detached HEAD, merge conflicts.
    *   *Mitigation:* Atomic operations, automatic lock cleanup, forced branch checkout.
4.  **Temporal Paradoxes ($E_{time}$):** System clock skew, timezone mismatches (e.g., committing "tomorrow" relative to server time).
    *   *Mitigation:* UTC normalization, server-time synchronization checks.

### Graceful Degradation
For any error $e \in E$:
1.  **Log:** Record full stack trace and context to structured log.
2.  **State Preservation:** Ensure `HEAD` is not left in a detached or dirty state.
3.  **Rollback:** If a batch operation fails (e.g., day 5 of 30), revert the local branch to the state at day 0 (Atomic Transaction).
